# Common Helm Chart Default Values
# All values are nested under 'common:' to avoid conflicts with external charts

common:
  # Application name (used for labels, selectors, service names)
  name: ""

  # Deployment configuration
  deployment:
    enabled: true  # Set to false when using external charts that create their own Deployment

  # Image configuration
  image:
    registry: zot0213.kro.kr
    repository: web-apps/app
    tag: latest
    pullPolicy: Always

  # Replicas
  replicaCount: 1

  # Container port (legacy - single port)
  containerPort: 3000

  # Container ports (new - multiple ports with names)
  # If defined, takes precedence over containerPort
  ports: []
  # - name: http
  #   containerPort: 8080
  #   protocol: TCP
  # - name: grpc
  #   containerPort: 9090
  #   protocol: TCP

  # Pod-level security context
  podSecurityContext: {}
  # runAsNonRoot: true
  # runAsUser: 1000
  # runAsGroup: 1000
  # fsGroup: 1000

  # Container-level security context
  securityContext: {}
  # runAsNonRoot: true
  # allowPrivilegeEscalation: false
  # readOnlyRootFilesystem: false
  # capabilities:
  #   drop:
  #     - ALL

  # Service configuration
  service:
    enabled: true
    type: ClusterIP
    port: 80           # Legacy single port
    # Multiple ports (new - takes precedence over port if defined)
    ports: []
    # - name: http
    #   port: 8080
    #   targetPort: http   # Can reference port name or number
    #   protocol: TCP
    # - name: grpc
    #   port: 9090
    #   targetPort: grpc
    #   protocol: TCP

  # Ingress configuration
  ingress:
    enabled: true
    className: traefik
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod
    hosts:
      - host: app.example.com
        paths:
          - path: /
            pathType: Prefix
    tls:
      - secretName: app-tls
        hosts:
          - app.example.com

  # Resources
  resources:
    requests:
      memory: 80Mi
      cpu: 20m
    limits:
      memory: 80Mi

  # Health checks
  healthCheck:
    enabled: true
    path: /                    # Default path (can be overridden per probe)
    port: ""                   # Port name or number (defaults to first port)
    livenessProbe:
      path: ""                 # Override path for liveness (defaults to healthCheck.path)
      initialDelaySeconds: 30
      periodSeconds: 10
    readinessProbe:
      path: ""                 # Override path for readiness (defaults to healthCheck.path)
      initialDelaySeconds: 5
      periodSeconds: 5
    startupProbe:              # Optional startup probe
      path: ""                 # Override path for startup (defaults to healthCheck.path)
      periodSeconds: 10
      failureThreshold: 30

  # Environment variables (plain)
  env: []
  # - name: NODE_ENV
  #   value: production

  # Environment variables from secrets
  envFrom: []
  # - secretRef:
  #     name: app-secrets

  # Vault Static Secrets (VSO)
  vaultStaticSecrets: []
  # - name: app-vss
  #   path: web-apps/myapp
  #   destination:
  #     name: app-secrets
  #     transformation:
  #       templates:
  #         SECRET_KEY: "{{ .Secrets.SECRET_KEY }}"

  # Deployment strategy
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1

  # Revision history
  revisionHistoryLimit: 3

  # Pod annotations
  podAnnotations: {}

  # Node selector
  nodeSelector: {}

  # Tolerations
  tolerations: []

  # Affinity - Soft Anti-Affinity to spread pods across nodes
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            topologyKey: kubernetes.io/hostname

  # RBAC configuration
  rbac:
    enabled: false
    serviceAccount:
      create: false
      name: ""  # If empty, defaults to app name
    clusterRoleBinding:
      roleRef:
        name: ""  # e.g., cluster-admin
    # Additional ClusterRoles with custom rules
    clusterRoles: []
    # - name: my-cluster-role
    #   rules:
    #     - apiGroups: [""]
    #       resources: ["pods"]
    #       verbs: ["get", "list"]
    # Additional ClusterRoleBindings
    clusterRoleBindings: []
    # - name: my-binding
    #   roleRef:
    #     kind: ClusterRole
    #     name: my-cluster-role
    #   subjects:
    #     - kind: ServiceAccount
    #       name: my-sa
    #       namespace: my-ns
    # Namespaced Roles
    roles: []
    # - name: my-role
    #   rules:
    #     - apiGroups: [""]
    #       resources: ["pods"]
    #       verbs: ["get", "list"]
    # Namespaced RoleBindings
    roleBindings: []
    # - name: my-rolebinding
    #   roleRef:
    #     kind: Role
    #     name: my-role
    #   subjects:
    #     - kind: ServiceAccount
    #       name: my-sa

  # ConfigMap configuration
  configMap:
    enabled: false
    name: ""  # If empty, defaults to <fullname>-config
    data: {}
    # key: value

  # Additional Ingresses (for health checks, embed routes, etc.)
  additionalIngresses: []
  # - name: health
  #   annotations:
  #     cert-manager.io/cluster-issuer: letsencrypt-prod
  #   className: traefik
  #   hosts:
  #     - host: app-health.example.com
  #       paths:
  #         - path: /
  #           pathType: Prefix
  #   tls:
  #     - secretName: app-health-tls
  #       hosts:
  #         - app-health.example.com
  #   serviceName: ""  # If empty, uses app name
  #   servicePort: 80

  # Traefik Middleware configuration
  middleware:
    enabled: false
    name: ""  # If empty, defaults to <fullname>-middleware
    stripPrefix:
      prefixes: []
    forwardAuth:
      address: ""
      trustForwardHeader: false
      authResponseHeaders: []

  # ServiceMonitor for Prometheus
  serviceMonitor:
    enabled: false
    endpoints: []
    # - port: http
    #   interval: 30s
    #   path: /metrics

  # StorageClass configuration
  storageClass:
    enabled: false
    name: ""
    provisioner: ""
    reclaimPolicy: Retain
    volumeBindingMode: WaitForFirstConsumer
    parameters: {}

  # PersistentVolumes (for local storage)
  persistentVolumes: []
  # - name: my-pv
  #   capacity: 10Gi
  #   accessModes:
  #     - ReadWriteOnce
  #   storageClassName: local-storage
  #   local:
  #     path: /mnt/data
  #   nodeAffinity:
  #     nodeSelectorTerms:
  #       - matchExpressions:
  #           - key: kubernetes.io/hostname
  #             operator: In
  #             values:
  #               - node1

  # ClusterIssuers for cert-manager
  clusterIssuers: []
  # - name: letsencrypt-prod
  #   server: https://acme-v02.api.letsencrypt.org/directory
  #   email: user@example.com
  #   privateKeySecretRef: letsencrypt-prod
  #   solvers:
  #     - ingressClass: traefik

  # CNPG Database configuration
  database:
    enabled: false
    instances: 2
    version: "16.6"
    name: ""        # Database name (defaults to app name + "DB")
    owner: ""       # Database owner (defaults to app name)
    storage:
      class: local-path
      size: 1Gi
    resources:
      memory: 256Mi
      cpu: 50m
    postgresql:
      parameters: {}  # Custom PostgreSQL parameters
    # pg_dump based backup (periodic, lower resource usage)
    dumpBackup:
      enabled: false
      schedule: "0 3 * * *"      # Daily at 3 AM
      retention: 7               # Keep last 7 backups
      bucket: ""                 # Defaults to <app>-db-backup
      volumeSize: "1Gi"
      minioEndpoint: "https://s3.minio0213.kro.kr"
      postgresImage: "zot0213.kro.kr/storage/postgresql:16.6"
      minioImage: "zot0213.kro.kr/storage/minio-mc:latest"
      successfulJobsHistoryLimit: 3
      failedJobsHistoryLimit: 3
